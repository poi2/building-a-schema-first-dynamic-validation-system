# Scenario test


UI E2E テストに **Playwright**、バックエンドテストに **Go (testcontainers-go)** を採用し、すべてを **Testcontainers** でラップする。

テストシナリオを、実装に依存しない **YAML 形式** で定義します。この YAML をテストランナーが読み込み、各フェーズを実行するイメージです。

---

### 1. シナリオ定義 (`scenarios/dynamic_validation.yaml`)

この YAML は、「どのような状態で」「何を操作し」「スキーマ変更後にどう変わるか」を記述します。

```yaml
scenario: "動的なバリデーションルールの更新と多層防御の検証"
description: "スキーマのパッチ更新により、アプリを再起動せずに制限が緩和されることを確認する"

environment:
  initial_schema_version: "v1.0.0"
  initial_rules:
    free_plan_limit: 100
  updated_schema_version: "v1.0.1"
  updated_rules:
    free_plan_limit: 200

steps:
  - name: "準備: ユーザー作成"
    action: "create_user"
    params:
      name: "Celo Tester"
      plan: "free"
    expected: "success"

  - name: "フェーズ1: 初期ルールでの検証"
    action: "submit_post"
    params:
      message_length: 150 # 100文字制限を超過
    expected:
      ui: "バリデーションエラーメッセージ（100文字制限）が表示されること"
      api_status: "INVALID_ARGUMENT"
      db_saved: false

  - name: "スキーマ更新の実行"
    action: "update_schema_patch"
    params:
      version: "v1.0.1"
      new_cel_expression: "this._plan == 'free' ? this.message.size() <= 200 : this.message.size() <= 300"
    expected: "ISRへのアップロードが成功すること"

  - name: "同期待機"
    action: "wait_for_sync"
    params:
      timeout_seconds: 40 # ポーリング周期を考慮

  - name: "フェーズ2: 更新ルールでの検証"
    action: "submit_post"
    params:
      message_length: 150 # 新しい200文字制限内
    expected:
      ui: "エラーが消え、送信ボタンが活性化し、投稿が成功すること"
      api_status: "OK"
      db_saved: true

  - name: "セキュリティ検証: 悪意のあるバイパス"
    action: "malicious_post"
    description: "クライアント側で _plan を premium に偽装して 250 文字送る"
    params:
      message_length: 250
      fake_plan: "premium" 
    expected:
      api_status: "INVALID_ARGUMENT" # BEがDBのplan(free)で上書きするため拒否される
      db_saved: false

```

---

### 2. テストスタックの構成

#### **A. BE Integration Test (Go + Testcontainers)**

* **役割**: API サーバー、ISR、DB を Docker コンテナとして立ち上げ、gRPC/Connect クライアントから直接リクエストを送り、DB の状態まで検証します。
* **Testcontainers-go**: `postgres`, `isr`, `be` の各イメージをソースコードから `FromDockerfile` でビルドし、ネットワークを繋いで起動します。

#### **B. UI E2E Test (Playwright + Testcontainers)**

* **役割**: ブラウザ操作を通じて、ユーザーの目に映るバリデーションの変化を検証します。
* **構成**:
* Node.js (Playwright) から Testcontainers を操作。
* フロントエンド (Vite/Next.js 等) を含む全スタックを Docker 上に展開。
* `page.locator()` で `data-testid` を指定して、リアクティブにエラー表示が消えるのを待ちます (`toPass` マッチャーの使用)。



---

### 3. 実行フローイメージ

自動テストを実行する際の `Makefile` ターゲットは以下のようになります。

```makefile
.PHONY: test-all
test-all: test-be test-ui

test-be:
	@echo "Running BE Integration Tests with Testcontainers..."
	go test -v ./tests/integration/...

test-ui:
	@echo "Running UI E2E Tests with Playwright..."
	# Testcontainers で環境を立ち上げた後に Playwright を実行
	npx playwright test

```

---

### 4. この設計のメリット

* **冪等性と再現性**: `testcontainers` を使うため、実行のたびに DB がクリアされ、ポートも動的に割り当てられるため、CI 環境でもローカル環境でも 100% 同じ結果が得られます。
* **シナリオの可読性**: YAML を見るだけで「この PoC で何を証明したいのか」が非エンジニアでも理解できます。
* **多層防御の証明**: YAML の最後のステップ（偽装リクエスト）により、スキーマ駆動バリデーションが単なる UI の飾りではなく、BE での厳密な保護に繋がっていることを自動証明できます。
