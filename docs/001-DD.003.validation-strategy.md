# Design Doc 3: バリデーション戦略設計 (Validation Strategy)

## 1. 目的

`protovalidate` (CEL) を用いて、リクエスト単体では完結しないビジネスルール（ユーザーのプランに応じた制限など）を、全レイヤーで一貫して検証する手法を定義する。

## 2. コンテキスト注入パターン (The Hidden Field Pattern)

`protovalidate` はメッセージ内のフィールドしか参照できません。そのため、判定に必要な外部変数をあらかじめメッセージに「注入」してからバリデーターに渡します。

### 2.1 .proto での定義

クライアント（FE）から送られるが、バリデーションロジックの判定に必要なコンテキストフィールドを定義します。

```protobuf
syntax = "proto3";
package celo.v1;

import "buf/validate/validate.proto";

message CreatePostRequest {
  string user_id = 1 [(buf.validate.field).string.uuid = true];
  string message = 2 [(buf.validate.field).cel = {
    id: "post.message.limit",
    // 注入された user_plan を参照して動的に閾値を変える
    expression: "this.user_plan == 'premium' ? this.message.size() <= 300 : this.message.size() <= 100",
    message: "Message length exceeds the limit for your plan"
  }];

  // Context Enrichment 用のフィールド（フィールド番号は 1000 以降を推奨）
  string user_plan = 1000;
}
```

## 3. レイヤー別実装詳細

### 3.1 Backend (Go) の Authoritative Validation

BE は「最終決定権」を持ち、クライアントから送られた `user_plan` は無視して DB の値を採用します。

* **手順**:
1. `req.UserId` を元に DB から最新の `user.plan` を取得。
2. `req.UserPlan = plan` (Go の struct フィールド) をセット。
3. `validator.Validate(req)` を実行。

* **メリット**: クライアントが `user_plan` を偽装してリクエストしても、BE で上書きされるため不正は不可能です。

### 3.2 BFF (Node.js) の透過的プロキシ

BFF は DB にアクセスせず、FE から受け取った `user_plan` をそのまま BE に転送します。

* **手順**:
1. FE から受け取ったリクエストをそのまま BE に転送。
2. PoC では認証・認可は簡易実装とする。

* **注意**: BFF はバリデーションを行わないため、不正なリクエストは BE で最終的に検証される。

### 3.3 Frontend (TypeScript) の Optimistic Validation

ユーザー体験（UX）向上のため、メモリ上の情報を用いて即時検証します。

* **手順**:
1. State に保持している `currentUser.user_plan` を `user_plan` フィールドにセット。
2. `validator.validate(req)` を実行し、エラーがあれば入力欄に赤字で表示。

* **前提**: FE は常に `current_user` を保持しており、`current_user.user_plan` が利用可能。

## 4. エラーハンドリングと国際化 (i18n)

`protovalidate` が返すエラーメッセージをどう扱うかを定義します。

* **基本方針**: `.proto` 内の `message` 属性には、翻訳のキー（例: `ERROR_MSG_LIMIT_EXCEEDED`）またはデフォルトの英語メッセージを記述。
* **フロントエンドの処理**: エラーレスポンスに含まれる `id`（例: `post.message.limit`）をキーとして、FE 側の辞書ファイルで多言語化されたメッセージに変換する。

## 5. ホットスワップ時のスレッドセーフティ (Go Implementation)

ISR から Patch が届いた際、リクエスト処理中にバリデーターを安全に差し替えるための Go 実装パターンです。

```go
type SchemaAwareValidator struct {
    // スレッドセーフな差し替えのために atomic.Value を使用
    v atomic.Value // *protovalidate.Validator
}

func (s *SchemaAwareValidator) Validate(ctx context.Context, msg proto.Message) error {
    v := s.v.Load().(*protovalidate.Validator)
    return v.Validate(msg)
}

func (s *SchemaAwareValidator) UpdateSchema(descriptor []byte) error {
    newV, err := protovalidate.New(protovalidate.WithDescriptorBytes(descriptor))
    if err != nil {
        return err
    }
    s.v.Store(newV)
    return nil
}
```
