# Design Doc 3: バリデーション戦略設計 (Validation Strategy)

## 1. 目的

`protovalidate` (CEL) を用いて、リクエスト単体では完結しないビジネスルール（ユーザーのプランに応じた制限など）を、全レイヤーで一貫して検証する手法を定義する。

## 2. コンテキスト注入パターン (The Hidden Field Pattern)

`protovalidate` はメッセージ内のフィールドしか参照できません。そのため、判定に必要な外部変数をあらかじめメッセージに「注入」してからバリデーターに渡します。

### 2.1 .proto での定義

クライアント（FE）から送られるが、バリデーションロジックの判定に必要なコンテキストフィールドを定義します。

```protobuf
syntax = "proto3";
package celo.v1;

import "buf/validate/validate.proto";

message CreatePostRequest {
  string user_id = 1 [(buf.validate.field).string.uuid = true];
  string message = 2 [(buf.validate.field).cel = {
    id: "post.message.limit",
    // 注入された user_plan を参照して動的に閾値を変える
    expression: "this.user_plan == 'premium' ? this.message.size() <= 300 : this.message.size() <= 100",
    message: "Message length exceeds the limit for your plan"
  }];

  // Context Enrichment 用のフィールド（フィールド番号は 1000 以降を推奨）
  string user_plan = 1000;
}
```

## 3. レイヤー別実装詳細

### 3.1 Backend (Go) の Authoritative Validation

BE は「最終決定権」を持ち、クライアントから送られた `user_plan` は無視して DB の値を採用します。

* **手順**:
  1. `req.UserId` を元に DB から最新の `user.plan` を取得。
  2. `req.UserPlan = plan` (Go の struct フィールド) をセット。
  3. `validator.Validate(req)` を実行。

* **メリット**: クライアントが `user_plan` を偽装してリクエストしても、BE で上書きされるため不正は不可能です。

* **CORS設定**: FE から直接アクセスされるため、適切な CORS ヘッダーを設定する必要があります。

### 3.2 Frontend (TypeScript) の Optimistic Validation

ユーザー体験（UX）向上のため、メモリ上の情報を用いて即時検証します。

* **手順**:
  1. State に保持している `currentUser.user_plan` を `user_plan` フィールドにセット。
  2. `validator.validate(req)` を実行し、エラーがあれば入力欄に赤字で表示。
  3. BE に直接リクエストを送信。

* **前提**: FE は常に `current_user` を保持しており、`current_user.user_plan` が利用可能。

* **必須フィールド**: `user_plan` は常に送信する必要がある。未設定（空文字列）の場合、BE でバリデーションエラー（`INVALID_ARGUMENT`）として扱われる。

* **protovalidate-ts の検証**: FE で protovalidate-ts を使用することで、TypeScript環境でのバリデーション統合を検証できます。

## 4. エラーハンドリングと国際化 (i18n)

`protovalidate` が返すエラーメッセージをどう扱うかを定義します。

* **基本方針**: `.proto` 内の `message` 属性には、翻訳のキー（例: `ERROR_MSG_LIMIT_EXCEEDED`）またはデフォルトの英語メッセージを記述。
* **フロントエンドの処理**: エラーレスポンスに含まれる `id`（例: `post.message.limit`）をキーとして、FE 側の辞書ファイルで多言語化されたメッセージに変換する。

## 5. ホットスワップ時のスレッドセーフティ (Go Implementation)

ISR から Patch が届いた際、リクエスト処理中にバリデーターを安全に差し替えるための Go 実装パターンです。

```go
type SchemaAwareValidator struct {
    // スレッドセーフな差し替えのために atomic.Value を使用
    v atomic.Value // *protovalidate.Validator
}

func (s *SchemaAwareValidator) Validate(ctx context.Context, msg proto.Message) error {
    v := s.v.Load().(*protovalidate.Validator)
    return v.Validate(msg)
}

func (s *SchemaAwareValidator) UpdateSchema(descriptor []byte) error {
    newV, err := protovalidate.New(protovalidate.WithDescriptorBytes(descriptor))
    if err != nil {
        return err
    }
    s.v.Store(newV)
    return nil
}
```

## 6. 実装アーキテクチャ (Task 3-2)

### 6.1 コンポーネント構成

**SchemaAwareValidator** (`services/be/internal/validator/`)
- `atomic.Value` を使ったスレッドセーフなバリデーター管理
- バージョン情報の保持
- descriptor bytes から protovalidate.Validator を生成

**SchemaManager** (`services/be/internal/schemamanager/`)
- ISR クライアントの管理
- 1分間隔での GetLatestPatch ポーリング
- バージョン比較とホットスワップロジック
- グレースフルシャットダウン対応

### 6.2 起動フロー

```
1. 環境変数読み取り (CELO_SCHEMA_TARGET, CELO_ISR_URL)
2. SchemaManager 初期化
3. ISR.GetLatestPatch() で初期スキーマ取得
4. SchemaAwareValidator 初期化
5. ログ出力: "Schema initialized: target=1.0, loaded version=1.0.X"
6. ポーリング goroutine 起動
7. サーバー起動
```

### 6.3 ポーリングフロー

```
毎分:
1. ISR.GetLatestPatch(major, minor) 呼び出し
2. 現在のバージョンと比較
3. 異なる場合:
   - SchemaAwareValidator.UpdateSchema() 呼び出し
   - atomic.Value で新しいバリデーターを差し替え
   - ログ出力: "Hot-swapped validator: 1.0.X -> 1.0.Y"
4. 同じ場合: 何もしない
```

### 6.4 エラーハンドリング

**起動時の ISR 接続失敗**:
- アプリケーション起動を失敗させる
- フォールバック（コンテナ同梱スキーマ）は本 PoC のスコープ外

**ポーリング時の ISR 接続失敗**:
- エラーログを出力して継続
- 現在のバリデーターを維持
- 次のポーリング間隔でリトライ

**スキーマパースエラー**:
- エラーログを出力
- 現在のバリデーターを維持（ホットスワップしない）

### 6.5 ログ出力仕様

- 起動時: `Schema initialized: target=1.0, loaded version=1.0.4`
- 更新検知時: `Hot-swapped validator: 1.0.4 -> 1.0.5`
- ポーリングエラー時: `Schema polling error (will retry in 1m0s): <error>`
- シャットダウン時: `Schema manager stopped`

## 7. 実装ステータス

### Task 3-2: 動的スキーマ同期 (Hot Reload) 実装 ✅ 完了

実装日: 2026-02-22

**実装されたコンポーネント**:
- ✅ `services/be/internal/validator/schema_aware_validator.go` - atomic.Valueを使ったスレッドセーフなバリデーター
- ✅ `services/be/internal/validator/schema_aware_validator_test.go` - 包括的なユニットテスト
- ✅ `services/be/internal/validator/testing_helpers.go` - テスト用ヘルパー関数
- ✅ `services/be/internal/schemamanager/config.go` - 設定構造体
- ✅ `services/be/internal/schemamanager/manager.go` - ISRポーリング＆ホットスワップロジック
- ✅ `services/be/internal/schemamanager/manager_test.go` - 包括的なユニットテスト
- ✅ `services/be/main.go` - 統合実装

**Acceptance Criteria**:
- ✅ アプリを止めずに、ログ上でスキーマバージョンの更新が確認できること
- ✅ ISR から `GetLatestPatch` を1分間隔でポーリングすること
- ✅ スキーマ更新時に `atomic.Value` を使ってバリデーターをスレッドセーフに差し替えること
- ✅ 起動時にターゲットとする `Major.Minor` バージョンをログ出力すること
- ✅ 更新検知時に `Hot-swapped validator: v1.0.4 -> v1.0.5` と出力すること

**テスト結果**:
- ✅ `validator` パッケージ: 6/6 テスト成功 (並行アクセステスト含む)
- ✅ `schemamanager` パッケージ: 6/6 テスト成功
- ✅ ビルドテスト: 成功

**環境変数**:
- `CELO_ISR_URL`: ISRサービスのURL (デフォルト: `http://localhost:50051`)
- `CELO_SCHEMA_TARGET`: ターゲットスキーマバージョン (デフォルト: `1.0`)
