# Design Doc 3: バリデーション戦略設計 (Validation Strategy)

## 1. 目的

`protovalidate` (CEL) を用いて、リクエスト単体では完結しないビジネスルール（ユーザーのプランに応じた制限など）を、全レイヤーで一貫して検証する手法を定義する。

## 2. コンテキスト注入パターン (The Hidden Field Pattern)

`protovalidate` はメッセージ内のフィールドしか参照できません。そのため、判定に必要な外部変数をあらかじめメッセージに「注入」してからバリデーターに渡します。

### 2.1 .proto での定義

クライアント（FE）からは送られない、検証専用のフィールドを定義します。

```protobuf
syntax = "proto3";
package celo.v1;

import "buf/validate/validate.proto";

message CreatePostRequest {
  string user_id = 1 [(buf.validate.field).string.uuid = true];
  string message = 2 [(buf.validate.field).cel = {
    id: "post.message.limit",
    // 注入された _plan を参照して動的に閾値を変える
    expression: "this._plan == 'premium' ? this.message.size() <= 300 : this.message.size() <= 100",
    message: "Message length exceeds the limit for your plan"
  }];

  // Context Enrichment 用のフィールド（フィールド番号は 1000 以降を推奨）
  string _plan = 1000; 
}
```

## 3. レイヤー別実装詳細

### 3.1 Backend (Go) の Authoritative Validation

BE は「最終決定権」を持ち、クライアントから送られた `_plan` は無視して DB の値を採用します。

* **手順**:
1. `req.UserId` を元に DB から最新の `user.plan` を取得。
2. `req.XPlan = plan` (Go の struct フィールド) をセット。
3. `validator.Validate(req)` を実行。

* **メリット**: クライアントが `_plan` を偽装してリクエストしても、BE で上書きされるため不正は不可能です。

### 3.2 BFF (Node.js) の Pre-flight Validation

BE に無駄なリクエストを投げないよう、セッション情報を用いて検証します。

* **手順**:
1. ログインセッションから `plan` を取得。
2. `req._plan = session.plan` をセットして検証。

### 3.3 Frontend (TypeScript) の Optimistic Validation

ユーザー体験（UX）向上のため、メモリ上の情報を用いて即時検証します。

* **手順**:
1. State に保持している `currentUser.plan` を `_plan` フィールドにセット。
2. `validator.validate(req)` を実行し、エラーがあれば入力欄に赤字で表示。

## 4. エラーハンドリングと国際化 (i18n)

`protovalidate` が返すエラーメッセージをどう扱うかを定義します。

* **基本方針**: `.proto` 内の `message` 属性には、翻訳のキー（例: `ERROR_MSG_LIMIT_EXCEEDED`）またはデフォルトの英語メッセージを記述。
* **フロントエンドの処理**: エラーレスポンスに含まれる `id`（例: `post.message.limit`）をキーとして、FE 側の辞書ファイルで多言語化されたメッセージに変換する。

## 5. ホットスワップ時のスレッドセーフティ (Go Implementation)

ISR から Patch が届いた際、リクエスト処理中にバリデーターを安全に差し替えるための Go 実装パターンです。

```go
type SchemaAwareValidator struct {
    // スレッドセーフな差し替えのために atomic.Value を使用
    v atomic.Value // *protovalidate.Validator
}

func (s *SchemaAwareValidator) Validate(ctx context.Context, msg proto.Message) error {
    v := s.v.Load().(*protovalidate.Validator)
    return v.Validate(msg)
}

func (s *SchemaAwareValidator) UpdateSchema(descriptor []byte) error {
    newV, err := protovalidate.New(protovalidate.WithDescriptorBytes(descriptor))
    if err != nil {
        return err
    }
    s.v.Store(newV)
    return nil
}
```
