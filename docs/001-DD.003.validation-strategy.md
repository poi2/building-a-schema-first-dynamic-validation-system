# Design Doc 3: バリデーション戦略設計 (Validation Strategy)

## 1. 目的

`protovalidate` (CEL) を用いて、リクエスト単体では完結しないビジネスルール（ユーザーのプランに応じた制限など）を、全レイヤーで一貫して検証する手法を定義する。

## 2. コンテキスト注入パターン (The Hidden Field Pattern)

`protovalidate` はメッセージ内のフィールドしか参照できません。そのため、判定に必要な外部変数をあらかじめメッセージに「注入」してからバリデーターに渡します。

### 2.1 .proto での定義

クライアント（FE）から送られるが、バリデーションロジックの判定に必要なコンテキストフィールドを定義します。

```protobuf
syntax = "proto3";
package celo.v1;

import "buf/validate/validate.proto";

message CreatePostRequest {
  string user_id = 1 [(buf.validate.field).string.uuid = true];
  string message = 2 [(buf.validate.field).cel = {
    id: "post.message.limit",
    // 注入された user_plan を参照して動的に閾値を変える
    expression: "this.user_plan == 'premium' ? this.message.size() <= 300 : this.message.size() <= 100",
    message: "Message length exceeds the limit for your plan"
  }];

  // Context Enrichment 用のフィールド（フィールド番号は 1000 以降を推奨）
  string user_plan = 1000;
}
```

## 3. レイヤー別実装詳細

### 3.1 Backend (Go) の Authoritative Validation

BE は「最終決定権」を持ち、クライアントから送られた `user_plan` は無視して DB の値を採用します。

* **手順**:
  1. `req.UserId` を元に DB から最新の `user.plan` を取得。
  2. `req.UserPlan = plan` (Go の struct フィールド) をセット。
  3. `validator.Validate(req)` を実行。

* **メリット**: クライアントが `user_plan` を偽装してリクエストしても、BE で上書きされるため不正は不可能です。

* **CORS設定**: FE から直接アクセスされるため、適切な CORS ヘッダーを設定する必要があります。

### 3.2 Frontend (TypeScript) の Optimistic Validation

ユーザー体験（UX）向上のため、メモリ上の情報を用いて即時検証します。

* **手順**:
  1. State に保持している `currentUser.user_plan` を `user_plan` フィールドにセット。
  2. `validator.validate(req)` を実行し、エラーがあれば入力欄に赤字で表示。
  3. BE に直接リクエストを送信。

* **前提**: FE は常に `current_user` を保持しており、`current_user.user_plan` が利用可能。

* **必須フィールド**: `user_plan` は常に送信する必要がある。未設定（空文字列）の場合、BE でバリデーションエラー（`INVALID_ARGUMENT`）として扱われる。

* **protovalidate-ts の検証**: FE で protovalidate-ts を使用することで、TypeScript環境でのバリデーション統合を検証できます。

## 4. エラーハンドリングと国際化 (i18n)

`protovalidate` が返すエラーメッセージをどう扱うかを定義します。

* **基本方針**: `.proto` 内の `message` 属性には、翻訳のキー（例: `ERROR_MSG_LIMIT_EXCEEDED`）またはデフォルトの英語メッセージを記述。
* **フロントエンドの処理**: エラーレスポンスに含まれる `id`（例: `post.message.limit`）をキーとして、FE 側の辞書ファイルで多言語化されたメッセージに変換する。

## 5. ホットスワップ時のスレッドセーフティ (Go Implementation)

ISR から Patch が届いた際、リクエスト処理中にバリデーターを安全に差し替えるための Go 実装パターンです。

```go
type SchemaAwareValidator struct {
    // スレッドセーフな差し替えのために atomic.Value を使用
    v atomic.Value // *protovalidate.Validator
}

func (s *SchemaAwareValidator) Validate(ctx context.Context, msg proto.Message) error {
    v := s.v.Load().(*protovalidate.Validator)
    return v.Validate(msg)
}

func (s *SchemaAwareValidator) UpdateSchema(descriptor []byte) error {
    newV, err := protovalidate.New(protovalidate.WithDescriptorBytes(descriptor))
    if err != nil {
        return err
    }
    s.v.Store(newV)
    return nil
}
```

## 6. 実装アーキテクチャ (Task 3-2)

### 6.1 コンポーネント構成

**SchemaAwareValidator** (`services/be/internal/validator/`)
- `atomic.Value` を使ったスレッドセーフなバリデーター管理
- バージョン情報の保持
- descriptor bytes から protovalidate.Validator を生成

**SchemaManager** (`services/be/internal/schemamanager/`)
- ISR クライアントの管理
- 1分間隔での GetLatestPatch ポーリング
- バージョン比較とホットスワップロジック
- グレースフルシャットダウン対応

### 6.2 起動フロー

```
1. 環境変数読み取り (CELO_SCHEMA_TARGET, CELO_ISR_URL)
2. SchemaManager 初期化
3. ISR.GetLatestPatch() で初期スキーマ取得
4. SchemaAwareValidator 初期化
5. ログ出力: "Schema initialized: target=1.0, loaded version=1.0.X"
6. ポーリング goroutine 起動
7. サーバー起動
```

### 6.3 ポーリングフロー

```
毎分:
1. ISR.GetLatestPatch(major, minor) 呼び出し
2. 現在のバージョンと比較
3. 異なる場合:
   - SchemaAwareValidator.UpdateSchema() 呼び出し
   - atomic.Value で新しいバリデーターを差し替え
   - ログ出力: "Hot-swapped validator: 1.0.X -> 1.0.Y"
4. 同じ場合: 何もしない
```

### 6.4 エラーハンドリング

**起動時の ISR 接続失敗**:
- アプリケーション起動を失敗させる
- フォールバック（コンテナ同梱スキーマ）は本 PoC のスコープ外

**ポーリング時の ISR 接続失敗**:
- エラーログを出力して継続
- 現在のバリデーターを維持
- 次のポーリング間隔でリトライ

**スキーマパースエラー**:
- エラーログを出力
- 現在のバリデーターを維持（ホットスワップしない）

### 6.5 ログ出力仕様

- 起動時: `Schema initialized: target=1.0, loaded version=1.0.4`
- 更新検知時: `Hot-swapped validator: 1.0.4 -> 1.0.5`
- ポーリングエラー時: `Schema polling error (will retry in 1m0s): <error>`
- シャットダウン時: `Schema manager stopped`

## 7. 実装ステータス

### Task 3-2: 動的スキーマ同期 (Hot Reload) 実装 ✅ 完了

実装日: 2026-02-22

**実装されたコンポーネント**:
- ✅ `services/be/internal/validator/schema_aware_validator.go` - atomic.Valueを使ったスレッドセーフなバリデーター
- ✅ `services/be/internal/validator/schema_aware_validator_test.go` - 包括的なユニットテスト
- ✅ `services/be/internal/validator/testing_helpers.go` - テスト用ヘルパー関数
- ✅ `services/be/internal/schemamanager/config.go` - 設定構造体
- ✅ `services/be/internal/schemamanager/manager.go` - ISRポーリング＆ホットスワップロジック
- ✅ `services/be/internal/schemamanager/manager_test.go` - 包括的なユニットテスト
- ✅ `services/be/main.go` - 統合実装

**Acceptance Criteria**:
- ✅ アプリを止めずに、ログ上でスキーマバージョンの更新が確認できること
- ✅ ISR から `GetLatestPatch` を1分間隔でポーリングすること
- ✅ スキーマ更新時に `atomic.Value` を使ってバリデーターをスレッドセーフに差し替えること
- ✅ 起動時にターゲットとする `Major.Minor` バージョンをログ出力すること
- ✅ 更新検知時に `Hot-swapped validator: v1.0.4 -> v1.0.5` と出力すること

**テスト結果**:
- ✅ `validator` パッケージ: 6/6 テスト成功 (並行アクセステスト含む)
- ✅ `schemamanager` パッケージ: 6/6 テスト成功
- ✅ ビルドテスト: 成功

**環境変数**:
- `CELO_ISR_URL`: ISRサービスのURL (デフォルト: `http://localhost:50051`)
- `CELO_SCHEMA_TARGET`: ターゲットスキーマバージョン (デフォルト: `1.0`)

### 7.1 実装結果と重要な制約事項

**⚠️ Critical Limitation: Hot Reload は機能しない**

実装・検証の結果、以下の技術的制約により**バリデーションルールの動的更新（Hot Reload）は実現できない**ことが判明しました。

#### 技術的な原因

1. **protovalidateの動作仕様**
   - `Validate(msg)`メソッドは`msg.ProtoReflect().Descriptor()`を使用
   - メッセージ自身が保持する**静的ディスクリプタ**を参照する
   - `WithMessageDescriptors()`で渡した動的ディスクリプタは使用されない
   - 参考: [protovalidate-go/validator.go](https://github.com/bufbuild/protovalidate-go/blob/main/validator.go)

2. **静的メッセージの制約**
   - `*userv1.CreateUserRequest`のような生成されたGo構造体は、コンパイル時に.pb.goファイルに埋め込まれたディスクリプタを使用
   - 実行時に異なるディスクリプタに差し替えることは不可能

3. **検証結果**
   - ISRから新しいスキーマ（v1.0.6、min_len:5）を取得
   - `Hot-swapped validator: 1.0.5 -> 1.0.6`ログ出力成功
   - しかし"Bob"（3文字）がバリデーション**通過**（本来はmin_len:5で拒否されるべき）
   - BEサービスをリビルド後、同じリクエストが**正しく拒否**される

#### 影響範囲

**破壊的変更の場合**:
- フィールド追加/削除/型変更など
- 古い.pb.goではパース不可
- → アプリケーションが動作しない

**非破壊的変更の場合**:
- バリデーションルールのみの変更（min_len: 1 → 5など）
- ISRからのホットスワップは成功
- → しかしバリデーションルールは更新されない

**結論**: いずれのケースでもHot Reloadは実用性がない

#### 実装されたコンポーネントの価値

SchemaManagerとSchemaAwareValidatorは以下の用途では機能します：

1. **動的メッセージ（dynamicpb.Message）との併用**
   - 静的メッセージではなく、動的に生成したメッセージであれば動的ディスクリプタが使用される可能性
   - ただし、Connect RPCハンドラーを含む大規模な書き換えが必要

2. **将来の拡張性**
   - 動的メッセージへの移行時の基盤として活用可能

#### 推奨される運用フロー

**通常のbuild -> runフロー**（検証済み）:

```bash
# 1. protoファイル編集
vim proto/user/v1/user.proto

# 2. コード生成
buf generate

# 3. リビルド・再起動
docker-compose build be
docker-compose up -d be

# 4. バリデーション動作確認
curl -X POST http://localhost:50052/user.v1.UserService/CreateUser ...
```

このフローでは、スキーマ更新とバリデーションルール更新が正常に動作することを確認済み。

**本番環境での推奨アプローチ**:
- Blue-Green Deployment
- Rolling Update
- Canary Release

これらの手法により、スキーマ更新時のダウンタイムを最小化できる。

#### 今後の選択肢

1. **動的メッセージへの全面移行** - 実装コスト大、Hot Reload可能
2. **カスタムバリデーター実装** - protovalidateを使わず独自実装、柔軟性高いがコスト大
3. **現実的なデプロイ戦略** - Hot Reloadを諦め、Blue-Greenなど標準的手法で対応（推奨）
